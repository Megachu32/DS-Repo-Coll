<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Universal Tree Data Structure Simulator</title>
    <style>
        :root {
            --bg-color: #f4f4f9;
            --panel-bg: #ffffff;
            --primary: #3498db;
            --accent: #e74c3c;
            --text: #2c3e50;
            --node-size: 50px;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            height: 100vh;
            display: flex;
            background-color: var(--bg-color);
            color: var(--text);
            overflow: hidden;
        }

        /* Layout 80% - 20% */
        #simulation-container {
            width: 80%;
            height: 100%;
            position: relative;
            background-color: #eef2f5;
            overflow: hidden; /* Changed to hidden to use drag/pan if needed, but auto is fine */
            border-right: 2px solid #ddd;
            display: flex;
            justify-content: center;
        }

        #control-panel {
            width: 20%;
            height: 100%;
            background-color: var(--panel-bg);
            display: flex;
            flex-direction: column;
            padding: 20px;
            box-sizing: border-box;
            box-shadow: -2px 0 5px rgba(0,0,0,0.05);
            z-index: 50;
        }

        #svg-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            pointer-events: none;
        }

        line {
            stroke: #95a5a6;
            stroke-width: 2;
            transition: all 0.5s ease;
        }

        .node {
            width: var(--node-size);
            height: var(--node-size);
            background-color: var(--panel-bg);
            border: 2px solid var(--primary);
            border-radius: 50%;
            position: absolute;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2;
            cursor: pointer;
            transition: all 0.5s ease, background-color 0.3s;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            font-size: 14px;
        }

        .node strong {
            font-size: 1.1rem;
            line-height: 1;
        }
        
        /* Specific style for Trie Leaf nodes */
        .node.is-leaf {
            border-color: #8e44ad;
            border-width: 3px;
        }
        .node.is-leaf::after {
            content: "END";
            font-size: 0.5rem;
            color: #8e44ad;
            position: absolute;
            bottom: 5px;
        }

        .node:hover {
            background-color: #d6eaf8;
            transform: scale(1.1);
            z-index: 10;
        }

        .node.highlight {
            background-color: #f1c40f;
            border-color: #f39c12;
        }

        .node.found {
            background-color: #2ecc71;
            color: white;
            border-color: #27ae60;
        }

        /* Controls Styling */
        h2 { margin-top: 0; font-size: 1.2rem; }
        
        .control-group { margin-bottom: 15px; }

        label { display: block; margin-bottom: 5px; font-weight: 600; font-size: 0.9rem;}

        select, input[type="text"], input[type="number"] {
            width: 100%;
            padding: 10px;
            margin-bottom: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box;
        }

        .button-group {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
        }

        button {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 4px;
            background-color: var(--primary);
            color: white;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.2s;
        }

        button:hover { background-color: #2980b9; }
        button:disabled { background-color: #95a5a6; cursor: not-allowed; }

        button.delete-btn { background-color: var(--accent); }
        button.delete-btn:hover { background-color: #c0392b; }

        /* Log Area */
        #log-area {
            flex: 1;
            background-color: #f8f9fa;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
            overflow-y: auto;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.85rem;
        }

        .log-entry {
            margin-bottom: 5px;
            border-bottom: 1px solid #eee;
            padding-bottom: 2px;
        }
        
        /* Helper for Trie instructions */
        .hint { font-size: 0.8rem; color: #666; margin-bottom: 5px; font-style: italic;}

    </style>
</head>
<body>

    <div id="simulation-container">
        <svg id="svg-layer"></svg>
        <div id="nodes-layer"></div>
    </div>

    <div id="control-panel">
        <h2>Tree Controller</h2>
        
        <div class="control-group">
            <label for="tree-type">Tipe Struktur Data:</label>
            <select id="tree-type">
                <option value="AVL">AVL Tree (Number)</option>
                <option value="HEAP">Max Heap (Number)</option>
                <option value="SPLAY">Splay Tree (Number)</option>
                <option value="TRIE">Prefix Trie (String)</option>
            </select>
        </div>

        <div class="control-group">
            <label for="node-value">Input:</label>
            <input type="text" id="node-value" placeholder="Masukkan nilai..." autocomplete="off"/>
            <div id="input-hint" class="hint">Masukkan angka integer.</div>
            
            <div class="button-group">
                <button id="btn-insert">Insert</button>
                <button id="btn-lookup">Lookup</button>
                <button id="btn-delete" class="delete-btn">Delete</button>
            </div>
        </div>

        <label>Activity Log:</label>
        <div id="log-area">
            <div class="log-entry">System ready. Default: AVL Tree.</div>
        </div>
    </div>

<script>
/**
 * UTILITIES
 */
const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

const logger = {
    area: document.getElementById('log-area'),
    add: function(text) {
        const div = document.createElement('div');
        div.className = 'log-entry';
        div.innerHTML = `> ${text}`;
        this.area.appendChild(div);
        this.area.scrollTop = this.area.scrollHeight;
    },
    clear: function() {
        this.area.innerHTML = '';
    }
};

function fmt(node) {
    if (!node) return "null";
    // For Trie nodes which store chars
    if (node.char !== undefined) return node.char === '*' ? 'ROOT' : `'${node.char}'`;
    return `${node.value}`;
}

/**
 * NODE CLASSES
 */

// Generic Binary Node (AVL, Heap, Splay)
class Node {
    constructor(value) {
        this.value = value;
        this.left = null;
        this.right = null;
        this.height = 1; 
        this.x = 0;
        this.y = 0;
        this.id = Math.random().toString(36).substr(2, 9); // Unique ID for DOM
    }
}

// Trie Node (Customized for Visualization)
class TrieNode {
    constructor(char = '*') {
        this.children = new Array(26).fill(null);
        this.isLeaf = false;
        this.char = char; // Character to display
        this.x = 0;
        this.y = 0;
        this.id = Math.random().toString(36).substr(2, 9);
    }
}

/**
 * VISUALIZATION ENGINE
 */
class TreeVisualizer {
    constructor() {
        this.container = document.getElementById('nodes-layer');
        this.svgLayer = document.getElementById('svg-layer');
        this.containerWidth = document.getElementById('simulation-container').offsetWidth;
    }

    reset() {
        this.container.innerHTML = '';
        this.svgLayer.innerHTML = '';
    }

    // Main Draw Function - Delegates based on node type
    draw(rootNode) {
        this.reset();
        if (!rootNode) return;

        // Check if it's a Trie (has children array) or Binary Tree (left/right)
        if (rootNode.children) {
            this.drawTrie(rootNode);
        } else {
            this.drawBinary(rootNode);
        }
    }

    // --- BINARY TREE LAYOUT ---
    drawBinary(rootNode) {
        const calculatePositions = (node, x, y, level) => {
            if (!node) return;
            node.x = x;
            node.y = y;
            const offset = (this.containerWidth / Math.pow(2, level + 2)); 
            calculatePositions(node.left, x - offset, y + 80, level + 1);
            calculatePositions(node.right, x + offset, y + 80, level + 1);
        };

        calculatePositions(rootNode, this.containerWidth / 2, 50, 0);
        this.renderRecursiveBinary(rootNode);
    }

    renderRecursiveBinary(node) {
        if (!node) return;
        if (node.left) {
            this.drawLine(node.x, node.y, node.left.x, node.left.y);
            this.renderRecursiveBinary(node.left);
        }
        if (node.right) {
            this.drawLine(node.x, node.y, node.right.x, node.right.y);
            this.renderRecursiveBinary(node.right);
        }
        this.createNodeElement(node);
    }

    // --- TRIE LAYOUT ---
    drawTrie(rootNode) {
        // Calculate X, Y coordinates
        // Simple strategy: Divide width by number of children at specific level
        // But better: recursive width assignment
        
        const leafCount = (node) => {
            let count = 0;
            let hasChildren = false;
            for(let c of node.children) {
                if(c) {
                    count += leafCount(c);
                    hasChildren = true;
                }
            }
            return hasChildren ? count : 1;
        };

        const totalLeaves = leafCount(rootNode);
        const sectorWidth = this.containerWidth / totalLeaves;
        let currentLeafIndex = 0;

        const assignCoords = (node, level) => {
            if(!node) return;
            
            // Check active children
            let activeChildren = node.children.filter(n => n !== null);
            
            // Y position based on level
            node.y = 50 + (level * 70);

            if (activeChildren.length === 0) {
                // It's a visual leaf (end of branch)
                node.x = (currentLeafIndex * sectorWidth) + (sectorWidth / 2);
                currentLeafIndex++;
            } else {
                // Process children first to determine parent X
                for (let i = 0; i < 26; i++) {
                    if (node.children[i]) assignCoords(node.children[i], level + 1);
                }
                // Parent X is average of first and last active child
                let firstChild = activeChildren[0];
                let lastChild = activeChildren[activeChildren.length - 1];
                node.x = (firstChild.x + lastChild.x) / 2;
            }
        };

        assignCoords(rootNode, 0);
        this.renderRecursiveTrie(rootNode);
    }

    renderRecursiveTrie(node) {
        if (!node) return;
        
        // Draw Lines to children
        for(let child of node.children) {
            if (child) {
                this.drawLine(node.x, node.y, child.x, child.y);
                this.renderRecursiveTrie(child);
            }
        }
        this.createNodeElement(node, true);
    }

    // --- SHARED RENDERING ---
    drawLine(x1, y1, x2, y2) {
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', x1);
        line.setAttribute('y1', y1 + 25); 
        line.setAttribute('x2', x2);
        line.setAttribute('y2', y2 + 25);
        this.svgLayer.appendChild(line);
    }

    createNodeElement(node, isTrie = false) {
        const div = document.createElement('div');
        div.className = 'node';
        if (isTrie && node.isLeaf) div.classList.add('is-leaf');

        div.style.left = (node.x - 25) + 'px'; 
        div.style.top = (node.y) + 'px';
        div.id = `node-${node.id}`; // Use internal unique ID
        
        let displayVal = node.value;
        if (isTrie) displayVal = node.char === '*' ? 'root' : node.char;

        div.innerHTML = `<strong>${displayVal}</strong>`;
        this.container.appendChild(div);
    }

    async highlight(nodeObj, className = 'highlight') {
        if (!nodeObj) return;
        const el = document.getElementById(`node-${nodeObj.id}`);
        if (el) {
            el.classList.add(className);
            await sleep(500);
            if (className !== 'found') {
                el.classList.remove(className);
            }
        }
    }
    
    clearHighlights() {
        const nodes = document.querySelectorAll('.node');
        nodes.forEach(n => n.classList.remove('found', 'highlight'));
    }
}

// === TRIE IMPLEMENTATION ===
class Trie {
    constructor(visualizer) {
        this.root = new TrieNode('*');
        this.vis = visualizer;
        this.vis.draw(this.root);
    }

    // Insert
    async insert(key) {
        key = key.toLowerCase();
        // Validation: only a-z
        if (!/^[a-z]+$/.test(key)) {
            logger.add("Error: Trie hanya menerima huruf a-z.");
            return;
        }

        logger.add(`Insert kata "${key}" ke Trie...`);
        let curr = this.root;
        await this.vis.highlight(curr);

        for (let c of key) {
            let index = c.charCodeAt(0) - "a".charCodeAt(0);
            
            if (curr.children[index] === null) {
                logger.add(`Buat node baru untuk '${c}'`);
                curr.children[index] = new TrieNode(c);
                this.vis.draw(this.root); // Redraw structure immediately
                await sleep(400); // Wait for user to see
            } else {
                logger.add(`Node '${c}' sudah ada, lanjut...`);
            }
            
            curr = curr.children[index];
            await this.vis.highlight(curr);
        }
        
        if (!curr.isLeaf) {
            curr.isLeaf = true;
            logger.add(`Tandai '${curr.char}' sebagai akhir kata.`);
            this.vis.draw(this.root); // To update the border color
            await this.vis.highlight(curr, 'found');
        } else {
            logger.add(`Kata "${key}" sudah ada sebelumnya.`);
        }
    }

    // Search
    async lookup(key) {
        key = key.toLowerCase();
        logger.add(`Mencari "${key}"...`);
        this.vis.clearHighlights();
        
        let curr = this.root;
        await this.vis.highlight(curr);

        for (let c of key) {
            let index = c.charCodeAt(0) - "a".charCodeAt(0);
            if (curr.children[index] === null) {
                logger.add(`Jalur '${c}' putus. Kata tidak ditemukan.`);
                return false;
            }
            curr = curr.children[index];
            await this.vis.highlight(curr);
        }
        
        if (curr.isLeaf) {
            logger.add(`DITEMUKAN: Kata "${key}" ada dalam Trie.`);
            await this.vis.highlight(curr, 'found');
            return true;
        } else {
            logger.add(`Prefix "${key}" ada, tapi bukan kata lengkap (bukan leaf).`);
            return false;
        }
    }

    // Delete (Recursive)
    async delete(key) {
        key = key.toLowerCase();
        logger.add(`Menghapus "${key}"...`);
        if(await this._delete(this.root, key, 0)) {
            logger.add(`Penghapusan "${key}" selesai.`);
            this.vis.draw(this.root);
        }
    }

    async _delete(node, key, depth) {
        // Helper to check if node has any children
        const isEmpty = (n) => {
            for (let i = 0; i < 26; i++) {
                if (n.children[i]) return false;
            }
            return true;
        };

        if (!node) return null;

        // Base Case: End of key
        if (depth === key.length) {
            if (node.isLeaf) {
                node.isLeaf = false; // Unmark leaf
                logger.add(`Hapus penanda akhir kata di node '${node.char}'.`);
                // If no children, this node can be deleted by returning null to parent
                if (isEmpty(node)) {
                    return null; 
                }
                return node;
            }
            logger.add(`Kata "${key}" tidak ditemukan sebagai kata lengkap.`);
            return node;
        }

        // Recursive Case
        let index = key.charCodeAt(depth) - "a".charCodeAt(0);
        let child = node.children[index];
        
        if (!child) {
            logger.add(`Path tidak ditemukan saat depth ${depth}. Batal.`);
            return node;
        }
        
        // Visualize traversal
        await this.vis.highlight(node);

        // Recurse
        node.children[index] = await this._delete(child, key, depth + 1);

        // Post-recursion cleanup
        // If child was deleted (returned null) AND current node is not leaf AND has no other children
        if (isEmpty(node) && !node.isLeaf && depth > 0) { // depth > 0 keeps root safe
            logger.add(`Node '${node.char}' tidak punya anak lain & bukan kata. Hapus.`);
            return null;
        }

        return node;
    }
}

// === AVL TREE ===
class AVLTree {
    constructor(visualizer) {
        this.root = null;
        this.vis = visualizer;
    }
    getHeight(node) { return node ? node.height : 0; }
    updateHeight(node) {
        if (node) node.height = 1 + Math.max(this.getHeight(node.left), this.getHeight(node.right));
    }
    getBalance(node) { return node ? this.getHeight(node.left) - this.getHeight(node.right) : 0; }

    rightRotate(y) {
        let x = y.left;
        let T2 = x.right;
        x.right = y;
        y.left = T2;
        this.updateHeight(y);
        this.updateHeight(x);
        return x;
    }

    leftRotate(x) {
        let y = x.right;
        let T2 = y.left;
        y.left = x;
        x.right = T2;
        this.updateHeight(x);
        this.updateHeight(y);
        return y;
    }

    async insert(value) {
        logger.add(`Insert ${value} ke AVL...`);
        this.root = await this._insert(this.root, value);
        this.vis.draw(this.root);
    }

    async _insert(node, value) {
        if (!node) return new Node(value);
        await this.vis.highlight(node);

        if (value < node.value) node.left = await this._insert(node.left, value);
        else if (value > node.value) node.right = await this._insert(node.right, value);
        else return node;

        this.updateHeight(node);
        let balance = this.getBalance(node);
        if (balance > 1 && value < node.left.value) return this.rightRotate(node);
        if (balance < -1 && value > node.right.value) return this.leftRotate(node);
        if (balance > 1 && value > node.left.value) {
            node.left = this.leftRotate(node.left);
            return this.rightRotate(node);
        }
        if (balance < -1 && value < node.right.value) {
            node.right = this.rightRotate(node.right);
            return this.leftRotate(node);
        }
        return node;
    }

    async delete(value) {
        this.root = await this._delete(this.root, value);
        this.vis.draw(this.root);
    }
    async _delete(node, value) {
        if (!node) return node;
        await this.vis.highlight(node);
        if (value < node.value) node.left = await this._delete(node.left, value);
        else if (value > node.value) node.right = await this._delete(node.right, value);
        else {
            if (!node.left || !node.right) {
                let temp = node.left ? node.left : node.right;
                if (!temp) node = null; else node = temp;
            } else {
                let temp = this.getMinValueNode(node.right);
                node.value = temp.value;
                node.right = await this._delete(node.right, temp.value);
            }
        }
        if (!node) return node;
        this.updateHeight(node);
        let balance = this.getBalance(node);
        if (balance > 1 && this.getBalance(node.left) >= 0) return this.rightRotate(node);
        if (balance > 1 && this.getBalance(node.left) < 0) {
            node.left = this.leftRotate(node.left);
            return this.rightRotate(node);
        }
        if (balance < -1 && this.getBalance(node.right) <= 0) return this.leftRotate(node);
        if (balance < -1 && this.getBalance(node.right) > 0) {
            node.right = this.rightRotate(node.right);
            return this.leftRotate(node);
        }
        return node;
    }
    getMinValueNode(node) {
        let current = node;
        while (current.left) current = current.left;
        return current;
    }
    async lookup(value) {
        this.vis.clearHighlights();
        let curr = this.root;
        while(curr) {
            await this.vis.highlight(curr);
            if(value == curr.value) {
                await this.vis.highlight(curr, 'found');
                return;
            }
            curr = value < curr.value ? curr.left : curr.right;
        }
        logger.add("Not Found.");
    }
}

// === MAX HEAP ===
class MaxHeap {
    constructor(visualizer) {
        this.vis = visualizer;
        this.heapNodes = []; 
    }
    buildTreeFromArray(index) {
        if (index >= this.heapNodes.length) return null;
        let nodeRef = this.heapNodes[index];
        nodeRef.left = this.buildTreeFromArray(2 * index + 1);
        nodeRef.right = this.buildTreeFromArray(2 * index + 2);
        return nodeRef;
    }
    updateView() {
        this.root = this.buildTreeFromArray(0);
        this.vis.draw(this.root);
    }
    async insert(value) {
        let newNode = new Node(value);
        this.heapNodes.push(newNode);
        this.updateView();
        await sleep(200);
        await this.heapifyUp(this.heapNodes.length - 1);
    }
    async heapifyUp(index) {
        if (index === 0) return;
        let parentIndex = Math.floor((index - 1) / 2);
        let current = this.heapNodes[index];
        let parent = this.heapNodes[parentIndex];
        await this.vis.highlight(current);
        await this.vis.highlight(parent);
        if (current.value > parent.value) {
            [this.heapNodes[index], this.heapNodes[parentIndex]] = [this.heapNodes[parentIndex], this.heapNodes[index]];
            this.updateView();
            await sleep(400);
            await this.heapifyUp(parentIndex);
        }
    }
    async delete(value) { // Basic delete (only exact match)
        const index = this.heapNodes.findIndex(n => n.value === value);
        if (index === -1) return;
        let lastNode = this.heapNodes.pop();
        if (index < this.heapNodes.length) {
            this.heapNodes[index] = lastNode;
            this.updateView();
            // Simple check: up or down?
            let parentIndex = Math.floor((index - 1) / 2);
            if (index > 0 && this.heapNodes[index].value > this.heapNodes[parentIndex].value) {
                await this.heapifyUp(index);
            } else {
                await this.heapifyDown(index);
            }
        } else {
            this.updateView();
        }
    }
    async heapifyDown(index) {
        let largest = index;
        let left = 2 * index + 1;
        let right = 2 * index + 2;
        if (left < this.heapNodes.length && this.heapNodes[left].value > this.heapNodes[largest].value) largest = left;
        if (right < this.heapNodes.length && this.heapNodes[right].value > this.heapNodes[largest].value) largest = right;
        if (largest !== index) {
            [this.heapNodes[index], this.heapNodes[largest]] = [this.heapNodes[largest], this.heapNodes[index]];
            this.updateView();
            await sleep(400);
            await this.heapifyDown(largest);
        }
    }
    async lookup(value) {
        this.vis.clearHighlights();
        for(let node of this.heapNodes) {
            await this.vis.highlight(node);
            if (node.value == value) {
                await this.vis.highlight(node, 'found');
                return;
            }
        }
    }
}

// === SPLAY TREE ===
class SplayTree {
    constructor(visualizer) {
        this.root = null;
        this.vis = visualizer;
    }
    rightRotate(x) {
        let y = x.left;
        x.left = y.right;
        y.right = x;
        return y;
    }
    leftRotate(x) {
        let y = x.right;
        x.right = y.left;
        y.left = x;
        return y;
    }
    async splay(node, key) {
        if (!node || node.value === key) return node;
        await this.vis.highlight(node);
        if (key < node.value) {
            if (!node.left) return node;
            if (key < node.left.value) {
                node.left.left = await this.splay(node.left.left, key);
                node = this.rightRotate(node);
            } else if (key > node.left.value) {
                node.left.right = await this.splay(node.left.right, key);
                if (node.left.right) node.left = this.leftRotate(node.left);
            }
            if (!node.left) return node;
            return this.rightRotate(node);
        } else {
            if (!node.right) return node;
            if (key < node.right.value) {
                node.right.left = await this.splay(node.right.left, key);
                if (node.right.left) node.right = this.rightRotate(node.right);
            } else if (key > node.right.value) {
                node.right.right = await this.splay(node.right.right, key);
                node = this.leftRotate(node);
            }
            if (!node.right) return node;
            return this.leftRotate(node);
        }
    }
    async insert(value) {
        if (!this.root) {
            this.root = new Node(value);
            this.vis.draw(this.root);
            return;
        }
        this.root = await this.splay(this.root, value);
        this.vis.draw(this.root);
        if (this.root.value === value) return;
        let newNode = new Node(value);
        if (value < this.root.value) {
            newNode.right = this.root;
            newNode.left = this.root.left;
            this.root.left = null;
        } else {
            newNode.left = this.root;
            newNode.right = this.root.right;
            this.root.right = null;
        }
        this.root = newNode;
        this.vis.draw(this.root);
    }
    async lookup(value) {
        this.vis.clearHighlights();
        this.root = await this.splay(this.root, value);
        this.vis.draw(this.root);
        if (this.root && this.root.value == value) await this.vis.highlight(this.root, 'found');
    }
    async delete(value) {
        if (!this.root) return;
        this.root = await this.splay(this.root, value);
        this.vis.draw(this.root);
        if (this.root.value !== value) return;
        if (!this.root.left) {
            this.root = this.root.right;
        } else {
            let rightTree = this.root.right;
            this.root = this.root.left;
            this.root = await this.splay(this.root, value); 
            this.root.right = rightTree;
        }
        this.vis.draw(this.root);
    }
}

/**
 * MAIN CONTROLLER
 */
const visualizer = new TreeVisualizer();
let currentTree = new AVLTree(visualizer);

const selectTree = document.getElementById('tree-type');
const inputVal = document.getElementById('node-value');
const inputHint = document.getElementById('input-hint');
const btnInsert = document.getElementById('btn-insert');
const btnLookup = document.getElementById('btn-lookup');
const btnDelete = document.getElementById('btn-delete');
let processing = false;

// Handle Mode Switch
selectTree.addEventListener('change', () => {
    visualizer.reset();
    logger.clear();
    const mode = selectTree.value;
    logger.add(`--- Mode berubah: ${mode} ---`);
    inputVal.value = '';
    
    // Switch logic
    switch(mode) {
        case 'AVL': 
            currentTree = new AVLTree(visualizer); 
            inputHint.innerText = "Masukkan angka integer.";
            break;
        case 'HEAP': 
            currentTree = new MaxHeap(visualizer); 
            inputHint.innerText = "Masukkan angka integer.";
            break;
        case 'SPLAY': 
            currentTree = new SplayTree(visualizer); 
            inputHint.innerText = "Masukkan angka integer.";
            break;
        case 'TRIE': 
            currentTree = new Trie(visualizer); 
            inputHint.innerText = "Masukkan string (a-z).";
            break;
    }
});

async function executeAction(action) {
    if (processing) return;
    
    let rawVal = inputVal.value.trim();
    if (!rawVal) return;

    // Type parsing based on mode
    let val;
    if (selectTree.value === 'TRIE') {
        val = rawVal;
    } else {
        val = parseInt(rawVal);
        if (isNaN(val)) {
            alert("Mode ini memerlukan input Angka!");
            return;
        }
    }

    processing = true;
    setButtonsDisabled(true);
    
    try {
        await action(val);
    } catch (e) {
        console.error(e);
        logger.add("Error: " + e.message);
    }

    processing = false;
    setButtonsDisabled(false);
    inputVal.value = '';
    inputVal.focus();
}

function setButtonsDisabled(state) {
    btnInsert.disabled = state;
    btnLookup.disabled = state;
    btnDelete.disabled = state;
}

btnInsert.addEventListener('click', () => executeAction(val => currentTree.insert(val)));
btnLookup.addEventListener('click', () => executeAction(val => currentTree.lookup(val)));
btnDelete.addEventListener('click', () => executeAction(val => currentTree.delete(val)));

// Allow Enter key
inputVal.addEventListener('keyup', (e) => {
    if (e.key === 'Enter') btnInsert.click();
});

</script>
</body>
</html>